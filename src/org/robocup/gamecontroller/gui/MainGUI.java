/*
  Copyright (C) 2005 University Of New South Wales.
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.robocup.gamecontroller.gui;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.Iterator;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.imageio.ImageIO;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JToggleButton;
import javax.swing.SwingConstants;
import javax.swing.Timer;
import javax.swing.UIManager;
import javax.swing.WindowConstants;
import javax.swing.border.TitledBorder;

import org.robocup.common.Constants;
import org.robocup.common.data.GameState;
import org.robocup.common.rules.RuleBook;
import org.robocup.common.util.LogFormatter;
import org.robocup.gamecontroller.data.RobotState;
import org.robocup.gamecontroller.gui.PlayerButton.Mode;
import org.robocup.gamecontroller.net.Broadcast;
import org.robocup.gamecontroller.net.Listener;

/**
 * MainGUI is the starting class of the program.
 * The GUI is shown and it interacts with a RoboCupGameControlData and starts a Broadcast on a new thread to broadcast the RoboCupGameControlData structure.
 * 
 * The majority of the GUI code is generated by NetBeans 4.
 * 
 * @author willu@cse.unsw.edu.au shnl327@cse.unsw.edu.au
 * 
 *         Modified by: 
 *         Tekin Mericli 
 *         Thomas Liebschwager (d3ni@informatik.uni-bremen.de; University of Bremen)
 */
public class MainGUI extends javax.swing.JFrame {

	private static final long serialVersionUID = 1L;

	private static Logger logger = Logger.getLogger("org.robocup.gamecontroller.gui.maingui");
	FileHandler logHandler = null;
	
	public static final byte TEAM_1 = Constants.TEAM_BLUE;
	public static final byte TEAM_2 = Constants.TEAM_RED;

	// create a RoboCupGameControlData for use
	private GameState data;

	// instance of the GameController to use for the GUI
	// the GameController thread is started in main
	private Broadcast broadcast;

	// The color of the kickoff team
	// -1 = not set, Constants.TEAM_BLUE or Constants.TEAM_RED
	private byte halfKickoffTeam = -1;

	private Listener listener;
	private GuiHandler handler;

	// private int leagueType;
	private RuleBook rulebook;

	private String[] teamNames = new String[Constants.NUM_TEAMS];

	int numPlayers;

	// Should we beep?
	private boolean quiet = false;

	static final int SPECIAL_EVENT_NONE = 0;
	static final int SPECIAL_EVENT_READY = 1;
	static final int SPECIAL_EVENT_HALFTIME = 2;
	static final int SPECIAL_EVENT_TEAM1_TIMEOUT = 3;
	static final int SPECIAL_EVENT_TEAM2_TIMEOUT = 4;

	int special_event = SPECIAL_EVENT_NONE;

	int[] numEjected = new int[Constants.NUM_TEAMS];

	/** Creates new form GUI */
	// team numbers are given by GameController to initialize data structure
	// and broadcast address to initialize the Broadcast class
	public MainGUI(RuleBook rulebook, String[] teamNames, byte[] teamNumbers, String broadcastAddr, int port, int range, int numPlayers, boolean quiet) {
		this.rulebook = rulebook;
		this.numPlayers = rulebook.getNumPlayers();
		secs = rulebook.getTimeSeconds();

		if(numPlayers != -1) {
			this.numPlayers = numPlayers;
		}		
		else if (this.numPlayers == -1) {
			this.numPlayers = Constants.NUM_PLAYERS_SPL;
		}	
		
		this.halfKickoffTeam = rulebook.getKickOffTeamColor();
		this.teamNames = teamNames;
		this.quiet = quiet;
		
		// create the GameController and RoboCupGameControlData
		// based on the command line arguments
		data = new GameState(rulebook, teamNumbers);
		broadcast = new Broadcast(data, broadcastAddr, port, range, Constants.NETWORK_HEARTBEAT);

		// start the GameController thread
		Thread broadcastThread = new Thread(broadcast);
		broadcastThread.start();

		handler = new GuiHandler();
		handler.setGui(this);

		initComponents();
        
        listener = new Listener(3838, handler);
		// listener = new Listener(port, handler);
		Thread t = new Thread(listener);
		t.start();

		// start timer object
		new Timer(timerInterval, clock).start();

		lblTime.setSeconds(secs); // initialize clockface

		TitledBorder borderTeam1 = new TitledBorder(null, teamNames[TEAM_1] + " - #" + teamNumbers[TEAM_1], TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12));
		TitledBorder borderTeam2 = new TitledBorder(null, teamNames[TEAM_2] + " - #" + teamNumbers[TEAM_2], TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12));

		// log handler
		try {
			logHandler = new FileHandler(Constants.LOG_FILENAME_GC, true); // append to logfile
			logger.addHandler(logHandler);
			logger.setLevel(Level.FINE);
			LogFormatter formatter = new LogFormatter();
		    logHandler.setFormatter(formatter);
		} catch (IOException e) {

		}
		
		logger.info("New Game: " + teamNames[0] + " (" + rulebook.getTeamColorName(0) + ") against " + teamNames[1] + " (" +rulebook.getTeamColorName(1) + ")");
		
		// initialize team panels with team names and numbers
		pnlTeam[TEAM_1].setBorder(borderTeam1);
		pnlTeam[TEAM_2].setBorder(borderTeam2);

		JPanel widestPanel = teamNames[TEAM_1].length() > teamNames[TEAM_2].length() ? pnlTeam[TEAM_1] : pnlTeam[TEAM_2];

		pnlTeam[TEAM_1].setPreferredSize(borderTeam1.getMinimumSize(widestPanel));
		pnlTeam[TEAM_2].setPreferredSize(borderTeam2.getMinimumSize(widestPanel));

		int windowWidth = Math.min(Math.max(1024, this.getWidth()), Toolkit.getDefaultToolkit().getScreenSize().width);
		this.setSize(new Dimension(windowWidth, this.getHeight()));
		this.setMinimumSize(new Dimension(720, 580));
		this.setLocationRelativeTo(null);

		// pack();
	}

	protected JToggleButton buildButton(String label, String toolTip) {
		JToggleButton button = new JToggleButton();
		button.setMargin(new Insets(2, 2, 2, 2));
		button.setText(label);
		button.setToolTipText(toolTip);
		return button;
	}

	private void initComponents() {
		setTitle(rulebook.getApplicationTitle());
		setName("frmMain");

		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent evt) {
				close(evt);
			}
		});

		getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.X_AXIS));

		JPanel pnlLeft = new JPanel();
		getContentPane().add(pnlLeft);
		pnlLeft.setLayout(new BoxLayout(pnlLeft, BoxLayout.Y_AXIS));

		JPanel pnlKickOff = initKickOffPanel();
		pnlLeft.add(pnlKickOff);

		JPanel pnlMain = initGameStatePanel();
		pnlLeft.add(pnlMain);

		JPanel pnlDetails = initGameDetailsPanel();
		pnlLeft.add(pnlDetails);

		// Dimension minSize = new Dimension(5, 0);
		// Dimension prefSize = new Dimension(5, 0);
		// Dimension maxSize = new Dimension(Short.MAX_VALUE, Short.MAX_VALUE);
		// pnlLeft.add(new Box.Filler(minSize, prefSize, maxSize));

		pnlLeft.add(Box.createVerticalGlue());

		JPanel pnlPenalties = initPenaltyPanel();
		getContentPane().add(pnlPenalties);

		JPanel pnlTeams = initTeamPanels();
		getContentPane().add(pnlTeams);

		JPanel pnlRight = new JPanel();
		getContentPane().add(pnlRight);
		pnlRight.setLayout(new BoxLayout(pnlRight, BoxLayout.Y_AXIS));

		// JPanel pnlScore = initScorePanel();
		pnlScore = initScorePanel();
		pnlRight.add(pnlScore);

		JPanel pnlTime = initTimePanel();
		pnlRight.add(pnlTime);

		JPanel pnlSpecialEventTime = initSpecialEventTimePanel();
		pnlRight.add(pnlSpecialEventTime);

		pack();
	}

	protected void initColorButton(JComponent button, Color color) {
		if(System.getProperty("os.name").equals("Mac OS X")) {
			button.setBackground(color);
			button.setOpaque(true);
		} else {
			button.setBorder(new DoubleLineBorder(Color.GRAY, color));
		}
	}

	protected JPanel initKickOffPanel() {
		JPanel pnlKickOff = new JPanel();
		pnlKickOff.setLayout(new GridLayout(0, 1, 5, 5));
		pnlKickOff.setBorder(new TitledBorder(null, "KickOff Team", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		kickOffButtons = new ButtonGroup();

		cmdTeamKickOff = new JToggleButton[Constants.NUM_TEAMS];
		
		UIManager.put ("ToggleButton.select", new Color(230, 230, 230)); 
		UIManager.put ("Button.select", new Color(230, 230, 230)); 
		
		for(byte j = 0; j < Constants.NUM_TEAMS; j++) {
			cmdTeamKickOff[j] = buildButton("<html><center>" + rulebook.getTeamColorName(j) + "<br/>KickOff</center></html>", "Click this button to select the " + rulebook.getTeamColorName(j) + " team for the next kick off.");
			cmdTeamKickOff[j].addActionListener(new KickOffAdapter(this, j));
			initColorButton(cmdTeamKickOff[j], rulebook.getTeamColor(j));
			kickOffButtons.add(cmdTeamKickOff[j]);
			pnlKickOff.add(cmdTeamKickOff[j]);			
		
		}
		
		cmdTeamKickOff[halfKickoffTeam].setSelected(true);

		if (rulebook.getDropBall()) {
			cmdDropBall = buildButton("<html><center>DropBall</center></html>", "Click this button to select a drop ball.");
			cmdDropBall.addActionListener(new KickOffAdapter(this, Constants.DROPBALL));

			kickOffButtons.add(cmdDropBall);
			pnlKickOff.add(cmdDropBall);
		}
		
		return pnlKickOff;
	}

	protected JPanel initGameStatePanel() {
		JPanel pnlMain = new JPanel();
		pnlMain.setLayout(new GridLayout(0, 1, 5, 5));
		pnlMain.setBorder(new TitledBorder(null, "Game State", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		gameButtons = new ButtonGroup();

		cmdInitial = buildButton("Initial", "Click this button to set the game to the \"Initial\" state.");
		cmdInitial.setSelected(true);
		cmdInitial.addActionListener(new GameStateAdapter(this, Constants.STATE_INITIAL));
		gameButtons.add(cmdInitial);
		pnlMain.add(cmdInitial);

		cmdReady = buildButton("Ready", "Click this button to set the game to the \"Ready\" state.");
		cmdReady.addActionListener(new GameStateAdapter(this, Constants.STATE_READY));
		gameButtons.add(cmdReady);
		pnlMain.add(cmdReady);

		cmdSet = buildButton("Set", "Click this button to set the game to the \"Set\" state.");
		cmdSet.addActionListener(new GameStateAdapter(this, Constants.STATE_SET));
		gameButtons.add(cmdSet);
		pnlMain.add(cmdSet);

		cmdKickOff = buildButton("Play", "Click this button to set the game to the \"Playing\" state.");
		cmdKickOff.addActionListener(new GameStateAdapter(this, Constants.STATE_PLAYING));
		gameButtons.add(cmdKickOff);
		pnlMain.add(cmdKickOff);

		cmdFinish = buildButton("Finish", "Click this button to set the game to the \"Finish\" state.");
		cmdFinish.addActionListener(new GameStateAdapter(this, Constants.STATE_FINISHED));
		gameButtons.add(cmdFinish);
		pnlMain.add(cmdFinish);

		cmdTeamDropIn = new JButton[Constants.NUM_TEAMS];
		
		for(byte j = 0; j < Constants.NUM_TEAMS; j++) {
			cmdTeamDropIn[j] = new JButton();
			initColorButton(cmdTeamDropIn[j], rulebook.getTeamColor(j));
			cmdTeamDropIn[j].setText("<html><center>Out By<br/>" + rulebook.getTeamColorName(j) + "</center></html>");
			cmdTeamDropIn[j].setToolTipText("Click when the " + rulebook.getTeamColorName(j) + " Team kicks the ball out");
			cmdTeamDropIn[j].addActionListener(new DropInAdapter(this, j));

			pnlMain.add(cmdTeamDropIn[j]);			
		}

		return pnlMain;
	}

	protected JPanel initGameDetailsPanel() {
		JPanel pnlDetails = new JPanel();
		pnlDetails.setLayout(new GridLayout(0, 1, 5, 5));
		pnlDetails.setBorder(new TitledBorder(null, "Game Details", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		chkAutoPause = new JCheckBox();
		chkAutoPause.setText("Auto Pause");
		chkAutoPause.setToolTipText("Check this option to automatically pause the clock when in \"Ready\" and \"Set\" states.");

		pnlDetails.add(chkAutoPause);

		return pnlDetails;
	}

	protected JPanel initPenaltyPanel() {
		JPanel pnlPenalties = new JPanel();
		pnlPenalties.setLayout(new GridLayout(0, 1, 5, 5));
		pnlPenalties.setBorder(new TitledBorder(null, "Penalties", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		penaltyButtons = new ButtonGroup();

		Iterator<Short> penalties = rulebook.getPenalties();
		int penalty = 0;
		while (penalties.hasNext()) {
			short code = ((Short) penalties.next()).shortValue();
			String name = rulebook.getPenaltyName(code);

			JToggleButton button = buildButton(name, "Sanction a \"" + name + "\" penalty to the selected players.");
			button.addActionListener(new PenaltyAdapter(this, code));
			penaltyButtons.add(button);
			pnlPenalties.add(button);
			penalty++;
		}

		cmdInvisible = new JToggleButton();
		cmdInvisible.setVisible(false);

		penaltyButtons.add(cmdInvisible);
		cmdInvisible.setSelected(true);

		return pnlPenalties;
	}

	protected JPanel initTeamPanels() {
		JPanel pnlTeams = new JPanel();
		pnlTeams.setLayout(new GridLayout(1, 2));

		pnlTeams.setBorder(new TitledBorder(null, "Teams", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		cmdTeam = new PlayerButton[Constants.NUM_TEAMS][Constants.MAX_NUM_PLAYERS];
		
		pnlTeam = new JPanel[Constants.NUM_TEAMS];
		lblTeamPushCount = new JLabel[Constants.NUM_TEAMS];
		goalColourTeam = new JComboBox[Constants.NUM_TEAMS];
		
		for(byte j = 0; j < Constants.NUM_TEAMS; j++) {
			pnlTeam[j] = new JPanel();
			pnlTeam[j].setLayout(new GridLayout(0, 1, 5, 5));
			pnlTeam[j].setBackground(rulebook.getTeamColor(j));

			if (rulebook.getChangeGoals()) {
				JLabel lblTeam1 = new JLabel();
				lblTeam1.setText("Own Goal Color:");
				pnlTeam[j].add(lblTeam1);

				goalColourTeam[j] = new JComboBox();
				pnlTeam[j].add(goalColourTeam[j]);
				goalColourTeam[j].addItem(rulebook.getGoalColorName(0));
				goalColourTeam[j].addItem(rulebook.getGoalColorName(1));
				goalColourTeam[j].setSelectedIndex(j);

				goalColourTeam[j].addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
						cmdChangeGoalColours(evt);
					}
				});				
			}			
			
            for (byte i = 0; i < Constants.MAX_NUM_PLAYERS; i++) {
                int player = i + 1;
				cmdTeam[j][i] = new PlayerButton(player, rulebook.getTeamColorName(j));
				cmdTeam[j][i].setMargin(new Insets(2, 5, 2, 5));
				cmdTeam[j][i].addActionListener(new PlayerAdapter(this, j, i));
            }
			for (byte i = 0; i < numPlayers; i++)
				pnlTeam[j].add(cmdTeam[j][i]);
            for (byte i = (byte) numPlayers; i < Constants.MAX_NUM_PLAYERS; i++) {
                // penalise all of the extra players (making them substitutes)
                data.setPenalty(j, i, Constants.PENALTY_SPL_SUBSTITUTE);
                teamPenaltyReason[j][i] = Constants.PENALTY_SPL_SUBSTITUTE;
            }
			
			pnlTeams.add(pnlTeam[j]);
			
			// if there is a limit for number of pushing penalties to be kept track of
			if (rulebook.getUsePushingCounter()) {
				
				lblTeamPushCount[j] = new JLabel("0", SwingConstants.CENTER);
				lblTeamPushCount[j].setFont(new Font("Dialog", 1, 50));
				lblTeamPushCount[j].setToolTipText(teamNames[j] + " push count.");
				lblTeamPushCount[j].setBorder(new TitledBorder(null, "# pushes", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));
				pnlTeam[j].add(lblTeamPushCount[j]);
			}
			
		}
        
		return pnlTeams;
	}

	protected JPanel initScorePanel() {
		// load the team logos
		String[] imageTypes = { ".gif", ".jpg", ".png" };
		Image[] teamLogos = new Image[Constants.NUM_TEAMS];

		try {
			int width = 180;// this.getWidth() / 3;
			int height = 60;// this.getHeight() / 3;

			for (int i = 0; i < Constants.NUM_TEAMS; i++) {
				teamLogos[i] = null;

				for (int j = 0; j < imageTypes.length && teamLogos[i] == null; j++) {
					String resource = File.separator + rulebook.getConfigDirectory() + File.separator + data.getTeamNumber((byte) i) + imageTypes[j];
					File file = new File("config" + resource);
					if (file.exists()) {
						teamLogos[i] = ImageIO.read(file);
						break;
					}
				}

				if (teamLogos[i] != null) {
					assert teamLogos[i].getWidth(this) > 0 && teamLogos[i].getHeight(this) > 0;

					if (width * teamLogos[i].getHeight(this) < height * teamLogos[i].getWidth(this)) {
						teamLogos[i] = teamLogos[i].getScaledInstance(width, -1, Image.SCALE_SMOOTH);
					} else {
						teamLogos[i] = teamLogos[i].getScaledInstance(-1, height, Image.SCALE_SMOOTH);
					}

					// teamLogos[i] = teamLogos[i].getScaledInstance(-1, height, Image.SCALE_SMOOTH);
				}
			}
		} catch (IOException e) {
			System.out.println("Error loading team logo images");
		}

		JPanel pnlScore = new JPanel();
		pnlScore.setLayout(new GridBagLayout());
		pnlTeamScore = new JPanel[Constants.NUM_TEAMS];
		pnlTeamScoreUpDown = new JPanel[Constants.NUM_TEAMS];
		
		for(byte j = 0; j < Constants.NUM_TEAMS; j++) {
			// JPanel pnlTeamScore = new JPanel();
			pnlTeamScore[j] = new JPanel();
			pnlTeamScore[j].setLayout(new GridBagLayout());

			pnlTeamScoreUpDown[j] = new JPanel();
			pnlTeamScoreUpDown[j].setLayout(new GridBagLayout());
		}


		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.NONE;
		constraints.anchor = GridBagConstraints.SOUTH;

		constraints.weightx = 0.2;
		constraints.weighty = 0.5;
		constraints.gridheight = 1;
		constraints.insets = new Insets(2, 2, 2, 2);

		pnlScore.setBorder(new TitledBorder(null, "Score", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));
		lblTeamLogo = new JLabel[Constants.NUM_TEAMS];
		teamLogo = new ImageIcon[Constants.NUM_TEAMS];
		lblTeam = new JLabel[Constants.NUM_TEAMS];
		lblTeamScore = new JLabel[Constants.NUM_TEAMS];
		cmdTeamScoreUp = new JButton[Constants.NUM_TEAMS];
		cmdTeamScoreDown = new JButton[Constants.NUM_TEAMS];
		
		for(byte j = 0; j < Constants.NUM_TEAMS; j++) {
			constraints.gridx = j;
			constraints.gridy = 0;
			final byte team = j; 
			
			lblTeamLogo[j] = new JLabel();
			if (teamLogos[j] != null) {
				teamLogo[j] = new ImageIcon(teamLogos[j]);
				lblTeamLogo[j].setIcon(teamLogo[j]);
			}
			
			lblTeam[j] = new JLabel();
			lblTeam[j].setFont(new Font("Dialog", 1, 15));
			lblTeam[j].setForeground(rulebook.getTeamColor(j));
			lblTeam[j].setText(teamNames[j]);
			lblTeam[j].setToolTipText(rulebook.getTeamColorName(j) + " team score.");
			
			pnlTeamScore[j].add(lblTeamLogo[j], constraints);
			
			constraints.gridy = 1;	
			

			pnlTeamScore[j].add(lblTeam[j], constraints);

			lblTeamScore[j] = new JLabel();
			lblTeamScore[j].setFont(new Font("Dialog", 1, 68));
			lblTeamScore[j].setText("0");
			lblTeamScore[j].setToolTipText(rulebook.getTeamColorName(j) + " team score.");

			constraints.gridy = 2;

			pnlTeamScore[j].add(lblTeamScore[j], constraints);

			cmdTeamScoreUp[j] = new JButton();
			cmdTeamScoreUp[j].setText("+");
			cmdTeamScoreUp[j].setFont(new Font("Dialog", 0, 20));
			cmdTeamScoreUp[j].setSize(25, 25);
			cmdTeamScoreUp[j].setToolTipText("Click to increment " + rulebook.getTeamColorName(j) + " score.");
			cmdTeamScoreUp[j].addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					cmdTeamScoreUp_clicked(evt, team);	
				}
			});

			constraints.gridy = 3;

			pnlTeamScoreUpDown[j].add(cmdTeamScoreUp[j]);

			cmdTeamScoreDown[j] = new JButton();
			cmdTeamScoreDown[j].setText("-");
			cmdTeamScoreDown[j].setFont(new Font("Dialog", 0, 20));
			cmdTeamScoreDown[j].setSize(25, 25);
			cmdTeamScoreDown[j].setToolTipText("Click to decrement " + rulebook.getTeamColorName(j) + " score.");
			cmdTeamScoreDown[j].addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					cmdTeamScoreDown_clicked(evt, team);
				}
			});

			pnlTeamScoreUpDown[j].add(cmdTeamScoreDown[j]);
			pnlTeamScore[j].add(pnlTeamScoreUpDown[j], constraints);			
		}

		constraints.gridy = 0;
		constraints.gridx = 0;

		pnlScore.add(pnlTeamScore[TEAM_1], constraints);

		constraints.gridx = 1;

		if (!rulebook.getSwitchTeamColorBetweenHalfs()) {
			cmdSwitchTeams = new JButton();
			cmdSwitchTeams.setText("< --- >");
			cmdSwitchTeams.setFont(new Font("Dialog", 0, 15));
			cmdSwitchTeams.setToolTipText("Click to switch team colour.");
			cmdSwitchTeams.setMargin(new Insets(2, 5, 2, 5));
			cmdSwitchTeams.addMouseListener(new MouseAdapter() {
				public void mouseClicked(MouseEvent evt) {
					cmdSwitchTeams_clicked(evt);
				}
			});
			pnlScore.add(cmdSwitchTeams, constraints);

			constraints.gridx = 2;
		}

		pnlScore.add(pnlTeamScore[TEAM_2], constraints);

		return pnlScore;
	}

	protected JPanel initTimePanel() {
		JPanel pnlTime = new JPanel();
		pnlTime.setLayout(new GridBagLayout());

		GridBagConstraints constraints = new GridBagConstraints();
		constraints.gridx = 0;
		constraints.gridy = 0;
		// constraints.weightx = 0.2;
		// constraints.weighty = 0.5;
		constraints.gridheight = 3;
		constraints.insets = new Insets(2, 2, 2, 2);

		pnlTime.setBorder(new TitledBorder(null, "Game Time", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		lblTime = new TimeTextField();
		lblTime.setFont(new Font("Dialog", 1, 36));
		lblTime.setSeconds(secs);
		lblTime.setToolTipText("Time remaining in half (unofficial). If you edit the time, press ENTER to commit the changes.");
		lblTime.setEnabled(false);
		lblTime.addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent evt) {
				lblTimeKeyPressed(evt);
			}
		});

		pnlTime.add(lblTime, constraints);

		cmdTimeStart = new JButton();
		cmdTimeStart.setText("Start / Stop");
		cmdTimeStart.setToolTipText("Start / Stop the timer.");
		cmdTimeStart.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent evt) {
				cmdTimeStart_clicked(evt);
			}
		});

		constraints.gridx = 1;
		constraints.gridy = 0;
		constraints.gridheight = 1;

		pnlTime.add(cmdTimeStart, constraints);

		cmdTimeReset = new JButton();
		cmdTimeReset.setText("Reset");
		cmdTimeReset.setToolTipText("Reset the timer.");
		cmdTimeReset.setMargin(new Insets(2, 2, 2, 2));
		cmdTimeReset.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent evt) {
				cmdTimeReset_clicked(evt);
			}
		});

		constraints.gridy = 1;

		pnlTime.add(cmdTimeReset, constraints);

		cmbHalf = new JComboBox();
		comboBoxModelHalf = new NamedComboBoxModel();
		comboBoxModelHalf.addElement("First Half", Constants.PLAY_MODE_FIRST_HALF);
		comboBoxModelHalf.addElement("Second Half", Constants.PLAY_MODE_SECOND_HALF);
		if (rulebook.getOvertimeSeconds() > 0) {
			comboBoxModelHalf.addElement("First Overtime", Constants.PLAY_MODE_FIRST_OVERTIME);
			comboBoxModelHalf.addElement("Second Overtime", Constants.PLAY_MODE_SECOND_OVERTIME);
		}
		comboBoxModelHalf.addElement("<html>Penalty Shoot<br/>&nbsp;&nbsp;" + teamNames[TEAM_1] + "</html>", Constants.PLAY_MODE_FIRST_TEAM_PENALTY);
		comboBoxModelHalf.addElement("<html>Penalty Shoot<br/>&nbsp;&nbsp;" + teamNames[TEAM_2] + "</html>", Constants.PLAY_MODE_SECOND_TEAM_PENALTY);

		cmbHalf.setModel(comboBoxModelHalf);
		cmbHalf.setToolTipText("Select whether the game is in first half, second half, overtime or penalty shoot. Changing this option will switch the teams around automatically.");
		cmbHalf.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				cmbHalfActionPerformed(evt);
			}
		});

		constraints.gridy = 2;

		pnlTime.add(cmbHalf, constraints);

		return pnlTime;
	}

	protected JPanel initSpecialEventTimePanel() {
		pnlSpecialEventTime = new JPanel();
		pnlSpecialEventTime.setLayout(new GridBagLayout());

		pnlSpecialEventTime.setBorder(new TitledBorder(null, "Special Time : No current event", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		lblSpecialEventTime = new TimeTextField();
		lblSpecialEventTime.setFont(new Font("Dialog", 1, 36));
		lblSpecialEventTime.setSeconds(0);
		lblSpecialEventTime.setToolTipText("Time remaining in event");
		lblSpecialEventTime.setEnabled(false);
		lblSpecialEventTime.addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent evt) {
				lblSpecialTimeKeyPressed(evt);
			}
		});

		GridBagConstraints constraints = new GridBagConstraints();
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.gridheight = 3;
		constraints.weightx = 1.0;
		constraints.insets = new Insets(2, 2, 2, 2);
		pnlSpecialEventTime.add(lblSpecialEventTime, constraints);

		cmdTimeOutDone = new JButton();

		cmdTimeOutDone.setText("<html><center>Time Out<br/>Done</center></html>");
		cmdTimeOutDone.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				cmdTimeOutDone_Selected(evt);
			}
		});
		
		constraints = new GridBagConstraints();
		constraints.gridx = 1;
		constraints.gridy = 0;
		constraints.fill = GridBagConstraints.HORIZONTAL;		
		constraints.weightx = 1.0;
		constraints.weighty = 1.0;
		constraints.insets = new Insets(2, 2, 2, 2);
		pnlSpecialEventTime.add(cmdTimeOutDone, constraints);		

		cmdTeamTimeOut = new JButton[Constants.NUM_TEAMS];
		
		for(byte j = 0; j < Constants.NUM_TEAMS; j++) {
			cmdTeamTimeOut[j] = new JButton();
			initColorButton(cmdTeamTimeOut[j], rulebook.getTeamColor(j));
			cmdTeamTimeOut[j].setText("<html><center>" + rulebook.getTeamColorName(j) + "<br/>Time Out</center></html>");
			
			final byte team = j;

			cmdTeamTimeOut[j].addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					cmdTeamTimeOut_Selected(evt, team);
				}
			});					
			
			constraints = new GridBagConstraints();
			constraints.gridx = 1;
			constraints.gridy = j+1;
			constraints.fill = GridBagConstraints.HORIZONTAL;
			constraints.weightx = 1.0;
			constraints.weighty = 1.0;
			constraints.insets = new Insets(2, 2, 2, 2);
			pnlSpecialEventTime.add(cmdTeamTimeOut[j], constraints);				
		}

		pnlSpecialEventTime.getAccessibleContext().setAccessibleName("Event Time : None");

		return pnlSpecialEventTime;
	}

	private void cmdTeamTimeOut_Selected(ActionEvent evt, byte team) {
		if ((special_event != SPECIAL_EVENT_NONE) && (eventSecs >= rulebook.getTimeOutSeconds())) {
			System.err.println("Ignoring timeout - too much time left on other event");

			if (!quiet) {
				Toolkit.getDefaultToolkit().beep();
			}

			return;
		}
		eventSecs = rulebook.getTimeOutSeconds();

		special_event = team == TEAM_1 ? SPECIAL_EVENT_TEAM1_TIMEOUT : SPECIAL_EVENT_TEAM2_TIMEOUT;
		cmdTeamKickOff[team == TEAM_1 ? TEAM_2 : TEAM_1].setSelected(true);
		data.setKickOffTeam(team == TEAM_1 ? TEAM_2 : TEAM_1);
		
		startClock = false;
		data.setGameState(Constants.STATE_INITIAL);
		setEventTitle(rulebook.getTeamColorName(team) + " Time Out");
	}

	private void cmdTimeOutDone_Selected(ActionEvent evt) {
		eventSecs = 0;
		// note: most of the work is actually done by the timer when it realises
		// it has now hit 0
	}

	// when changing the clock time, the time needs to be applied to the data
	// structure and the GUI
	private void lblTimeKeyPressed(KeyEvent evt) {
		if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
			logger.fine("commit time change");

			try {
				secs = parseTime(lblTime.getText());
			} catch (ParseException e) { // ignore -> no update
			}
			lblTime.setSeconds(secs);
		}
	}

	private void lblSpecialTimeKeyPressed(KeyEvent evt) {
		if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
			logger.fine("commit event time change");

			try {
				eventSecs = parseTime(lblSpecialEventTime.getText());
			} catch (ParseException e) { // ignore -> no update
			}
			lblSpecialEventTime.setSeconds(eventSecs);
		}
	}

	private double parseTime(String str) throws ParseException {
		double m = 0, s = 0;
		String[] parts = str.split(":", 2);
		if (parts.length == 2) {
			m = new DecimalFormat("00").parse(parts[0]).doubleValue();
			s = new DecimalFormat("00.0").parse(parts[1]).doubleValue();
		} else if (parts.length == 1) {
			s = new DecimalFormat("00.0").parse(parts[0]).doubleValue();
		}
		return m * 60 + s;
	}

	private void cmbHalfActionPerformed(ActionEvent evt) {
		Short playMode = comboBoxModelHalf.getSelectedIndex();
		
		boolean isFirst = playMode == Constants.PLAY_MODE_FIRST_HALF || playMode == Constants.PLAY_MODE_FIRST_OVERTIME;
		boolean isHalf = playMode == Constants.PLAY_MODE_FIRST_HALF || playMode == Constants.PLAY_MODE_SECOND_HALF;
		boolean isOvertime = playMode == Constants.PLAY_MODE_FIRST_OVERTIME || playMode == Constants.PLAY_MODE_SECOND_OVERTIME;
		boolean isPenaltyShoot = playMode == Constants.PLAY_MODE_FIRST_TEAM_PENALTY || playMode == Constants.PLAY_MODE_SECOND_TEAM_PENALTY;

		for(byte i = 0; i < Constants.NUM_TEAMS ; i++) {
			cmdTeamScoreDown[i].setEnabled(true);
			cmdTeamScoreUp[i].setEnabled(true);
		}
		
		if (isPenaltyShoot) {
			data.setSecondaryGameState(Constants.STATE2_PENALTYSHOOT);
			data.setGameState(Constants.STATE_INITIAL);
			cmdInitial.setSelected(true);

			boolean shotA = playMode == Constants.PLAY_MODE_FIRST_TEAM_PENALTY;
			boolean blueKickoff = (halfKickoffTeam == Constants.TEAM_BLUE);
			boolean currentShotA = (data.getHalf() == blueKickoff);

			if (shotA == currentShotA) {
				logger.info("Penalty Shoot: " + teamNames[shotA ? TEAM_1 : TEAM_2] + " (" + rulebook.getTeamColorName(shotA ? TEAM_1 : TEAM_2) + ")");
			
				switchTeams();
				data.setHalf(!data.getHalf());
			}
			
			byte kickoffTeam = rulebook.getSwitchTeamColorBetweenHalfs() ? Constants.TEAM_RED : shotA ? TEAM_1 : TEAM_2;
			byte otherTeam = (kickoffTeam == TEAM_2 ? TEAM_1 : TEAM_2);
				
			data.setKickOffTeam(kickoffTeam);
			cmdTeamKickOff[kickoffTeam].setSelected(true);
			
			cmdTeamScoreDown[otherTeam].setEnabled(false);
			cmdTeamScoreUp[otherTeam].setEnabled(false);
			cmdTeamScoreDown[kickoffTeam].setEnabled(true);
			cmdTeamScoreUp[kickoffTeam].setEnabled(true);	
			
			setGameState(Constants.STATE_INITIAL);
			
		} else {
			if (isHalf) {
				data.setSecondaryGameState(Constants.STATE2_NORMAL);
			} else if (isOvertime) {
				data.setSecondaryGameState(Constants.STATE2_OVERTIME);
			}

			if (isFirst != data.getHalf()) {
				data.setHalf(isFirst);
				switchTeams();
				if (!rulebook.getSwitchTeamColorBetweenHalfs()) {
					cmdTeamKickOff[TEAM_1 == halfKickoffTeam ? TEAM_2 : TEAM_1].setSelected(true);
					data.setKickOffTeam(TEAM_1 == halfKickoffTeam ? TEAM_2 : TEAM_1);
				}
				else{
					cmdTeamKickOff[halfKickoffTeam].setSelected(true);
					data.setKickOffTeam(halfKickoffTeam);
				}
			}
		}
		cmdTimeReset_clicked(null);
	}

	// need to change the team numbers, colours, and scores around when the
	// halves are changed
	private void switchTeams() {
		if (rulebook.getSwitchTeamColorBetweenHalfs()) {
			switchLogosNumbersScoresNames();

		} else {
			// swap team goal color
			byte tempGoalColor = data.getGoalColour(TEAM_1);
			data.setGoalColour(TEAM_1, data.getGoalColour(TEAM_2));
			data.setGoalColour(TEAM_2, tempGoalColor);

			goalColourTeam[TEAM_1].setSelectedIndex(data.getGoalColour(TEAM_1));
			goalColourTeam[TEAM_2].setSelectedIndex(data.getGoalColour(TEAM_2));
		}

		// System.out.println("Team0: " + data.getScore(TEAM_0) + " Team1: " + data.getScore(TEAM_1));

		if (rulebook.getUsePushingCounter()) {
			rulebook.resetPushingCounter();

			lblTeamPushCount[TEAM_1].setText("" + rulebook.getPushingCounter(TEAM_1) + "");
			lblTeamPushCount[TEAM_2].setText("" + rulebook.getPushingCounter(TEAM_2) + "");

			numEjected[TEAM_1] = 0;
			numEjected[TEAM_2] = 0;
		}

		// reset the drop in time and team
		data.resetDropIn();

		// Unpenalize all robots, even the ejected ones
		unpenaliseAll(true, false);

		// System.out.println("Team0: number: " + data.getTeamNumber(TEAM_0) + " score: " + data.getScore(TEAM_0) + " Team1: number: " + data.getTeamNumber(TEAM_1) + " score: " + data.getScore(TEAM_1));

		// pack();
	}

	private void switchLogosNumbersScoresNames() {
		// swap team logos
		ImageIcon tempLogo = (ImageIcon) lblTeamLogo[TEAM_1].getIcon();
		lblTeamLogo[TEAM_1].setIcon(lblTeamLogo[TEAM_2].getIcon());
		lblTeamLogo[TEAM_2].setIcon(tempLogo);

		// swap team numbers
		byte tempTeam = data.getTeamNumber(TEAM_1);
		data.setTeamNumber(TEAM_1, data.getTeamNumber(TEAM_2));
		data.setTeamNumber(TEAM_2, tempTeam);

		// swap team scores
		byte tempScore = data.getScore(TEAM_1);
		data.setScore(TEAM_1, data.getScore(TEAM_2));
		data.setScore(TEAM_2, tempScore);

		// swap team names
		String tempName = teamNames[TEAM_1];
		teamNames[TEAM_1] = teamNames[TEAM_2];
		teamNames[TEAM_2] = tempName;

		logger.info("Switch Team Colors: " + teamNames[TEAM_1] + " (" + rulebook.getTeamColorName(TEAM_1) + "), " + teamNames[TEAM_2] + " (" + rulebook.getTeamColorName(TEAM_2) + ")");

		// change the team numbers in the panel borders
		pnlTeam[TEAM_1].setBorder(new TitledBorder(null, teamNames[TEAM_1] + " - #" + data.getTeamNumber(TEAM_1), TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));
		pnlTeam[TEAM_2].setBorder(new TitledBorder(null, teamNames[TEAM_2] + " - #" + data.getTeamNumber(TEAM_2), TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, new Font("Dialog", 1, 12)));

		// change the scores
		lblTeamScore[TEAM_1].setText("" + data.getScore(TEAM_1));
		lblTeamScore[TEAM_2].setText("" + data.getScore(TEAM_2));

		lblTeam[TEAM_1].setForeground(rulebook.getTeamColor(TEAM_1));
		lblTeam[TEAM_2].setForeground(rulebook.getTeamColor(TEAM_2));
		lblTeam[TEAM_1].setText(teamNames[TEAM_1]);
		lblTeam[TEAM_2].setText(teamNames[TEAM_2]);
	}

	/***************************************************************************
	 * 
	 * Unpenalise buttons
	 * 
	 ***************************************************************************/

	// unpenalise the specified player
	public void unpenalisePlayer(byte team, byte player) {
		logger.fine("Clicked on unpenalise (Team: " + team + ", Player: " + (player + 1));

		PlayerButton button = cmdTeam[team][player];
		button.setPenalty(Constants.PENALTY_NONE, 0);

		data.setPenalty(team, player, Constants.PENALTY_NONE);
		teamPenaltyCountdown[team][player] = 0;
	}

	// wrapper for GUIUnpenalised to unpenalise all GUI elements
	private void unpenaliseAll(boolean includeEjected, boolean penaltyTimeStayOnStateChange) {
		if(!rulebook.getPenaltyTimeStayOnStateChange() || penaltyTimeStayOnStateChange) {
			for (byte team = 0; team < Constants.NUM_TEAMS; team++) {
				for (byte player = 0; player < Constants.MAX_NUM_PLAYERS; player++) {
					if (includeEjected || teamPenaltyCountdown[team][player] != -1) {
						if(!rulebook.getPenaltyStayOnStateChange(teamPenaltyReason[team][player])) {
							unpenalisePlayer(team, player);
							data.resetPenalty(team, player);
						}
						else teamPenaltyCountdown[team][player] = 0;
					}
				}
		}
			// data.resetPenalties();
		}	
	}
	
	// wrapper for GUIIgnore request for pickups to all GUI elements
	private void clearRequestsAll()
	{
		for (byte team = 0; team < Constants.NUM_TEAMS; team++) 
			for (byte player = 0; player < cmdTeam[team].length; player++) 
				cmdTeam[team][player].setRequest(false);
	}

	// reset the clock
	private void cmdTimeReset_clicked(MouseEvent evt) {
		if (data.getSecondaryGameState() == Constants.STATE2_OVERTIME) {
			secs = rulebook.getOvertimeSeconds();
		} else if (data.getSecondaryGameState() == Constants.STATE2_PENALTYSHOOT) {
			secs = rulebook.getPenaltyShootSeconds();
		} else {
			secs = rulebook.getTimeSeconds();
		}

		lblTime.setSeconds(secs);
	}

	// start/pause the clock
	private void cmdTimeStart_clicked(MouseEvent evt) {
		startClock = !startClock;
		cmbHalf.setEnabled(!startClock); // only enable changing of halves when
		// the clock is paused
	}

	/***************************************************************************
	 * 
	 * Code to modify the scores
	 * 
	 **************************************************************************/
	// events for the up/down score buttons. Need to concat "" since setText
	// only accepts strings, not ints
	// 1) count up/down score
	// 2) set the score in the data structure
	// 3) update the score on the GUI
	// 4) change kick off teams in GUI
	// 5) change kick off teams in data structure
	// 6) change state to "ready" if necessary (in GUI and data structure)
	private void cmdTeamScoreDown_clicked(ActionEvent evt, byte team) {
		byte teamScore = data.getScore(team);
		if (teamScore > 0) {
			teamScore--;
		}
		
		logger.info(teamNames[TEAM_1] + " (" + rulebook.getTeamColorName(team) + ") " + " loses a goal [" + teamNames[TEAM_1] + " (" + rulebook.getTeamColorName(TEAM_1) + ") " + data.getScore(TEAM_1) + " : " + data.getScore(TEAM_2) + " " + teamNames[TEAM_2] + "(" + rulebook.getTeamColorName(TEAM_2) + ")]" );
		
		data.setScore(team, teamScore);
		lblTeamScore[team].setText("" + teamScore);
	}

	private void cmdTeamScoreUp_clicked(ActionEvent evt, byte team) {
		byte teamScore = data.getScore(team);
		teamScore++;
		data.setScore(team, teamScore);
		lblTeamScore[team].setText("" + teamScore);

		Short playMode = comboBoxModelHalf.getSelectedIndex();
		
		logger.info(teamNames[TEAM_1] + " (" + rulebook.getTeamColorName(team) + ") " + " scrore [" + teamNames[TEAM_1] + "(" + rulebook.getTeamColorName(TEAM_1) + ") " + data.getScore(TEAM_1) + " : " + data.getScore(TEAM_2) + " "+ teamNames[TEAM_1] + "(" + rulebook.getTeamColorName(TEAM_2) + ")]" );
		

		cmdTeamKickOff[team == TEAM_1 ? TEAM_2 : TEAM_1].setSelected(true);
		data.setKickOffTeam(team == TEAM_1 ? TEAM_2 : TEAM_1);

		unpenaliseAll(false, false);
		if(playMode == Constants.PLAY_MODE_FIRST_TEAM_PENALTY || playMode == Constants.PLAY_MODE_SECOND_TEAM_PENALTY ) {
			this.setGameState(Constants.STATE_FINISHED);
			data.setGameState(Constants.STATE_FINISHED);
			cmdFinish.setSelected(true);

			setEventTitle("Ready");
			eventSecs = rulebook.getReadySeconds();
			special_event = SPECIAL_EVENT_READY;			
		}else{
			data.setGameState(Constants.STATE_READY);
			cmdReady.setSelected(true);

			setEventTitle("Ready");
			eventSecs = rulebook.getReadySeconds();
			special_event = SPECIAL_EVENT_READY;			
		}
	}

	

	private void cmdSwitchTeams_clicked(MouseEvent evt) {
		switchLogosNumbersScoresNames();
	}

	/***************************************************************************
	 * 
	 * Applies the selected penalty / player combination to the data structure
	 * 
	 **************************************************************************/

	protected short selectedPenalty = Constants.PENALTY_NONE;
	protected int selectedPlayerTeam = TEAM_1;
	protected int selectedPlayerNumber = -1;

	// this function is called by the player/penalty button clicks
	// it applies the selected penalty to the selected player(s)
	private void applyPenalty(short team, short player, short code) {
		short time = rulebook.getPenaltyTime(code);

		logger.info("Applying " + rulebook.getPenaltyName(code) + " to " + teamNames[team] + "(" + rulebook.getTeamColorName(team) + ") " + (player + 1));
		data.setPenalty((byte) team, (byte) player, code);
		teamPenaltyCountdown[team][player] = time;
		teamPenaltyReason[team][player] = code;

		if (rulebook.getUsePushingCounter() && code == Constants.PENALTY_SPL_PLAYER_PUSHING && rulebook.getPushingCounter((byte) team) == rulebook.getPushingThreshold(numEjected[team]) -1) {
			teamPenaltyCountdown[team][player] = -1;
			logger.info("Applying " + "Ejected to " + teamNames[team] + "(" + rulebook.getTeamColorName(team) + ") " + (player + 1));
			numEjected[team]++;

			if (numEjected[team] >= numPlayers - 1) {
				numEjected[team]--;
			}
		}		

		if (rulebook.getUsePushingCounter() && code == Constants.PENALTY_SPL_PLAYER_PUSHING) {
			rulebook.incrementPushingCounter((byte) team);

			lblTeamPushCount[TEAM_1].setText("" + rulebook.getPushingCounter(TEAM_1) + "");
			lblTeamPushCount[TEAM_2].setText("" + rulebook.getPushingCounter(TEAM_2) + "");
		}
        
        if (code == Constants.PENALTY_SPL_SUBSTITUTE) {
            // if the penalty is a request for substitution check to see if there is a sub waiting
            int subplayer = getSubstitutePlayerNumber(team);
            if (subplayer != -1) {
                // if there is swap the penalised player and the sub
                logger.info("Substitute " + subplayer + " replacing " + player);
                data.setPenalty((byte) team, (byte) subplayer, Constants.PENALTY_SPL_REQUEST_FOR_PICKUP);
                teamPenaltyCountdown[team][subplayer] = time;
                teamPenaltyReason[team][subplayer] = code;
                
                Component[] comps = pnlTeam[team].getComponents();
                int locationforsub = 0;
                for (int i = 0; i < comps.length; i++)
                {
                    try {
                        PlayerButton button = (PlayerButton) comps[i];
                        if (button.player-1 == player)
                            locationforsub = i;
                    } catch (ClassCastException e) {}
                }
                
                pnlTeam[team].remove(cmdTeam[team][player]);
                pnlTeam[team].add(cmdTeam[team][subplayer], locationforsub);
            }
        }

		// System.out.println("usePushingCounter: " + rulebook.getUsePushingCounter() + " code: " + code + " team1 push: " + rulebook.getPushingCounter(TEAM_0) + " team2 push: " + rulebook.getPushingCounter(TEAM_1));

		unselectPenalty(); // clear all selections after a penalty is given
		updatePenaltyButtons();
	}
    
    // this function returns the player number of the substitute robot on game controller. If there is no sub, -1 is returned
    private int getSubstitutePlayerNumber(short team) {
        for (int i = 0; i < Constants.MAX_NUM_PLAYERS; i++) {
            if (!isOnField(team, i) && (System.currentTimeMillis() - data.getTimeLastSeen((byte) team, (byte) i) < Constants.LASTSEEN_INDICATOR_THRESHOLD[0]))
                return i;
        }
        return -1;
    }
    
    // this function returns true if the robot is playing the game
    private boolean isOnField(short team, int player) {
        Component[] comps = pnlTeam[team].getComponents();
        for (int i = 0; i < comps.length; i++)
        {
            try {
                PlayerButton button = (PlayerButton) comps[i];
                if (button.player-1 == player)
                    return true;
            } catch (ClassCastException e) {
                
            }
            
        }
        return false;
    }
    
    // this function is called when a return packet that requests for a pickup is received
    // it asks the user of the GC whether the robot can be picked up (and replaced)
    private void requestForSubstitute(short team, short player) {
        logger.info("Request for subsitute from " + teamNames[team] + "(" + rulebook.getTeamColorName(team) + ") " + (player + 1)); 
        PlayerButton button = cmdTeam[team][player];
        button.setRequest(true);
    }

	private void applyAddonPenalty(short team, short player, short code) {
		short time = rulebook.getPenaltyTime(code);


		logger.info("Applying " + rulebook.getPenaltyName(code) + " to " + rulebook.getTeamColorName(team) + " " + (player + 1));
		data.setPenalty((byte) team, (byte) player, code);
		teamPenaltyCountdown[team][player] += time;

		unselectPenalty(); // clear all selections after a penalty is given
		updatePenaltyButtons();
	}

	// unselects everything in the GUI for a penalty
	private void unselectPenalty() {
		selectedPenalty = Constants.PENALTY_NONE;
		cmdInvisible.setSelected(true); // don't select any penalty
		for (int i = 0; i < cmdTeam[TEAM_1].length; i++) {
			cmdTeam[TEAM_1][i].setSelected(false);
			cmdTeam[TEAM_2][i].setSelected(false);
		}
	}

	// Player/Penalty button clicks

	public void cmdPlayerClicked(int team, int player) {
		logger.fine("Clicked on " + rulebook.getTeamColorName(team) + " " + (player + 1));

		PlayerButton button = cmdTeam[team][player];

		if (button.mode == Mode.modeNORMAL) {
			if (selectedPenalty != Constants.PENALTY_NONE) {
				applyPenalty((short) team, (short) player, selectedPenalty);
				button.mode = Mode.modeUNPENALIZE;
			} else {
				if (selectedPlayerTeam != team || selectedPlayerNumber != player) {
					if (selectedPlayerNumber != -1) {
						PlayerButton prevButton = cmdTeam[selectedPlayerTeam][selectedPlayerNumber];
						prevButton.setSelected(false);
					}
					selectedPlayerTeam = team;
					selectedPlayerNumber = player;
				} else {
					button.setSelected(false);
					selectedPlayerTeam = TEAM_1;
					selectedPlayerNumber = -1;
				}
			}
		} else if (button.mode == Mode.modeREQUEST) {
			if (selectedPenalty != Constants.PENALTY_NONE) {			// if one of the penalties are selected then 'over rule' the request for substitution
				applyPenalty((short) team, (short) player, selectedPenalty);
				button.mode = Mode.modeUNPENALIZE;
			} else {
				applyPenalty((short) team, (short) player, Constants.PENALTY_SPL_SUBSTITUTE);
				button.mode = Mode.modeUNPENALIZE;
			}
		} else {
			if (selectedPenalty != Constants.PENALTY_NONE && rulebook.getPenaltyIsAddon(selectedPenalty)) {
				applyAddonPenalty((short) team, (short) player, selectedPenalty);
			} else {
				unpenalisePlayer((byte) team, (byte) player);
				button.setSelected(false);
			}
		}
	}

	public void penalty_clicked(short code) {
		logger.fine("Clicked on a penalty");

		short selectedPlayer = 0;
		short selectedTeam = TEAM_1;
		boolean playerSelected = false;
		for (byte j = 0; j < Constants.NUM_TEAMS; j++)
			for (byte i = 0; i < cmdTeam[j].length; i++) {
				if (cmdTeam[j][i].isSelected()) {
					selectedPlayer = i;
					selectedTeam = j;
					playerSelected = true;
					break;
				}
			}

		if (playerSelected) {
			applyPenalty(selectedTeam, selectedPlayer, code);
		} else {
			if (selectedPenalty != code) {
				selectedPenalty = code;
				clearRequestsAll();
			} else {
				cmdInvisible.setSelected(true);
				selectedPenalty = Constants.PENALTY_NONE;
			}
		}
	}

	public void cmdChangeGoalColours(ActionEvent evt) {
		JComboBox source = (JComboBox) evt.getSource();
		JComboBox other = (evt.getSource() == goalColourTeam[TEAM_1]) ? goalColourTeam[TEAM_2] : goalColourTeam[TEAM_1];

		if(other.getSelectedIndex() == source.getSelectedIndex()) {
			Short playMode = comboBoxModelHalf.getSelectedIndex();
			if(playMode != Constants.PLAY_MODE_FIRST_TEAM_PENALTY && playMode != Constants.PLAY_MODE_SECOND_TEAM_PENALTY)
					logger.info("Switch Goal Colors: " + teamNames[TEAM_1] + " (" + rulebook.getGoalColorName(goalColourTeam[TEAM_1].getSelectedIndex() == 0 ? Constants.GOAL_BLUE : Constants.GOAL_YELLOW) + "), " + teamNames[TEAM_2] + " (" + rulebook.getGoalColorName(goalColourTeam[TEAM_2].getSelectedIndex() == 0 ? Constants.GOAL_YELLOW : Constants.GOAL_BLUE) + ")");
		}
		other.setSelectedIndex((source.getSelectedIndex() == 0) ? 1 : 0);
		

		data.setGoalColour(TEAM_1, (goalColourTeam[TEAM_1].getSelectedIndex() == 0) ? Constants.GOAL_BLUE : Constants.GOAL_YELLOW);
		data.setGoalColour(TEAM_2, (goalColourTeam[TEAM_2].getSelectedIndex() == 0) ? Constants.GOAL_BLUE : Constants.GOAL_YELLOW);
	}

	public void setEventTitle() {
		setEventTitle(null);
	}

	public void setEventTitle(String title) {
		if (title == null) {
			title = "No current event";
		}
		((TitledBorder) pnlSpecialEventTime.getBorder()).setTitle("Special Time : " + title);
		pnlSpecialEventTime.repaint(1000);
	}

	// Game Button clicks, these update the data structure and put the game into
	// a specified state, some of these states also reset all penalties

	public void setGameState(byte state) {
		Byte oldGameState = data.getGameState();
		
		unpenaliseAll(state == Constants.STATE_FINISHED, false);
		
		if (state == Constants.STATE_PLAYING) {
			// burst SET when switching from READY to PLAYING (keep correct state sequence)
			if(oldGameState == Constants.STATE_READY) {  
				data.setGameState(Constants.STATE_SET);
				broadcast.setBurst(true);
			}
			data.setGameState(state);
			startClock = true;
			broadcast.setBurst(true);
			if (halfKickoffTeam == -1) {
				halfKickoffTeam = data.getKickOffTeam();
			}
		} else if (state == Constants.STATE_READY) {
			eventSecs = rulebook.getReadySeconds();
			special_event = SPECIAL_EVENT_READY;
			setEventTitle("Ready");
			
			if (comboBoxModelHalf.getSelectedIndex() == Constants.PLAY_MODE_SECOND_HALF)
				logger.info("Start second half");
			else if (comboBoxModelHalf.getSelectedIndex() == Constants.PLAY_MODE_FIRST_OVERTIME)
				logger.info("Start first overtime");
			else if (comboBoxModelHalf.getSelectedIndex() == Constants.PLAY_MODE_SECOND_OVERTIME)
				logger.info("Start second overtime");			
		} else if (state == Constants.STATE_FINISHED) {
			startClock = false;
			
			if (comboBoxModelHalf.getSelectedIndex() == Constants.PLAY_MODE_FIRST_HALF) {
				setEventTitle("Half-time");
				logger.info("End first half");
				eventSecs = rulebook.getHalfTimeSeconds();
				special_event = SPECIAL_EVENT_HALFTIME;
			}
			else if (comboBoxModelHalf.getSelectedIndex() == Constants.PLAY_MODE_FIRST_OVERTIME)
				logger.info("End first overtime");
			else if (comboBoxModelHalf.getSelectedIndex() == Constants.PLAY_MODE_SECOND_OVERTIME)
				logger.info("End second overtime");				
		}
		
		data.setGameState(state);
	}

	public void setKickOff(byte team) {
		if (team == Constants.DROPBALL) {
			logger.fine("Clicked on Drop Ball");
		} else {
			logger.fine("Clicked on " + rulebook.getTeamColorName(team) + " Kick Off");
		}
		data.setKickOffTeam(team);
	}

	public void setDropIn(byte team) {
		logger.fine("Clicked on " + rulebook.getTeamColorName(team) + " Drop In");
		data.setDropInTeam(team);
	}

	private void close(WindowEvent evt) {
		logger.fine("GUI closing");
		broadcast.socketCleanup();
	}

	/*******************************************************************************
	 * 
	 * A timer to time the penalty countdown and the clock
	 * 
	 *******************************************************************************/
	private static final double oneSecond = 1000; // oneSecond in milliseconds
	private static final int timerInterval = 100; // interval of clock event in
	// milliseconds

	// initial clock values
	private double secs = 0;

	// initial event clock values
	private double eventSecs = 0;

	// flags set by clock buttons to start/stop it
	private boolean startClock = false;
	
	// these arrays hold the penalty countdown values for each player
	private double[][] teamPenaltyCountdown = new double[Constants.NUM_TEAMS][Constants.MAX_NUM_PLAYERS];
	private short[][] teamPenaltyReason = new short[Constants.NUM_TEAMS][Constants.MAX_NUM_PLAYERS];
		

	// call other methods that need the time
	private ActionListener clock = new ActionListener() {
		public void actionPerformed(ActionEvent evt) {
			int oldSecs = (int) Math.ceil(secs);
		    updateClock(); // update GUI clock
			updateEventClock();
			updatePenaltyCountDown(); // update penalty button countdowns
			updateEstimatedSecs(); // update secs remaining in struct
			if((int) Math.ceil(secs) != oldSecs) {
				data.updateDropInTime(); // update drop in team/time
			}
		}
	};

	// updates the number of seconds remaining in the half
	// also indicates whether overtime has occurred using true/false
	private void updateEstimatedSecs() {
		if (secs >= 0) {
			data.setEstimatedSecs((int) Math.floor(secs), false);
		} else {
			data.setEstimatedSecs(0, true);
		}
	}

	// update any penalty countdowns in both the data structure and the GUI
	private void updatePenaltyCountDown() {
		double diff = timerInterval / oneSecond;
		for (int j = 0; j < Constants.NUM_TEAMS; j++)
			for (int i = 0; i < teamPenaltyCountdown[j].length; i++) {
				if (teamPenaltyCountdown[j][i] != -1) { // not ejected
					if (teamPenaltyCountdown[j][i] > diff) {
						teamPenaltyCountdown[j][i] -= diff;
					} else {
						teamPenaltyCountdown[j][i] = 0;
					}
				}
			}
		updatePenaltyButtons();
	}

	private void updatePenaltyButtons() {
		for (byte i = 0; i < cmdTeam[TEAM_1].length; i++) {
			cmdTeam[TEAM_1][i].setPenalty(data.getPenalty(TEAM_1, i), teamPenaltyCountdown[TEAM_1][i]);
			cmdTeam[TEAM_2][i].setPenalty(data.getPenalty(TEAM_2, i), teamPenaltyCountdown[TEAM_2][i]);

			data.setSecsTillUnpenalised(TEAM_1, i, (short) (teamPenaltyCountdown[TEAM_1][i] == -1 ? data.getEstimatedSecs() : teamPenaltyCountdown[TEAM_1][i]));
			data.setSecsTillUnpenalised(TEAM_2, i, (short) (teamPenaltyCountdown[TEAM_2][i] == -1 ? data.getEstimatedSecs() : teamPenaltyCountdown[TEAM_2][i]));
		}
	}

	private void updateEventClock() {
		if (special_event == SPECIAL_EVENT_NONE) {
			return;
		}

		double diff = timerInterval / oneSecond;

		eventSecs -= diff;
		if ((special_event == SPECIAL_EVENT_TEAM1_TIMEOUT) || (special_event == SPECIAL_EVENT_TEAM2_TIMEOUT)) {
			if (eventSecs < 0) {
				special_event = SPECIAL_EVENT_READY;
				gameButtons.setSelected(cmdReady.getModel(), true);
				data.setGameState(Constants.STATE_READY);
				unpenaliseAll(false, false);
				setEventTitle("Ready");
				eventSecs = rulebook.getReadySeconds();
				startClock = true; // start the clock here - will be stopped
				// again later if chkAutoPause is on
			}
		} else if ((special_event == SPECIAL_EVENT_READY) || (data.getGameState() == Constants.STATE_READY)) {
			if (special_event != SPECIAL_EVENT_READY) {
				logger.warning("Weirdness in MainGUI.updateEventClock(): special_event should be READY");
			}
			if (data.getGameState() != Constants.STATE_READY) {
				setEventTitle(null);
				special_event = SPECIAL_EVENT_NONE;
				eventSecs = 0;
			} else if (eventSecs <= 0) {
				special_event = SPECIAL_EVENT_NONE;
				eventSecs = 0;
				if (rulebook.getAutomaticReady2Set()) {
					logger.info("Automatic switch to Set");
					gameButtons.setSelected(cmdSet.getModel(), true);
					data.setGameState(Constants.STATE_SET);
					unpenaliseAll(false, false);
					setEventTitle(null);
				}
			}
		} else if (special_event == SPECIAL_EVENT_HALFTIME) {
			if (Math.abs(eventSecs - rulebook.getHalfTimeSeconds() / 2) < 0.001) {
				cmbHalf.setSelectedIndex(1);
				gameButtons.setSelected(cmdInitial.getModel(), true);
				data.setGameState(Constants.STATE_INITIAL);
			}
			if (eventSecs < 0) {
				special_event = SPECIAL_EVENT_NONE;
				startClock = false;
			}
		} else {
			logger.warning("Unknown event type in MainGUI.updateEventClock(): " + special_event + " - ignoring.");
			special_event = SPECIAL_EVENT_NONE;
			setEventTitle(null);
			eventSecs = 0;
		}

		lblSpecialEventTime.setSeconds(eventSecs);
	}

	// count down the clock
	private void updateClock() {
		// the clock stops if auto pause is enabled and the game is in the
		// "Ready" or "Set" states
		if ((data.getGameState() == Constants.STATE_READY || data.getGameState() == Constants.STATE_SET) && chkAutoPause.isSelected()) {
			startClock = false;
		}

		cmbHalf.setEnabled(!startClock);
		lblTime.setEnabled(!startClock);

		if (startClock) {
			double diff = timerInterval / oneSecond;
			secs -= diff;
			lblTime.setSeconds(secs);

			if (!quiet) {
				if (secs >= 0 && secs <= 10 && Math.abs(secs - Math.floor(secs)) < diff) {
					Toolkit.getDefaultToolkit().beep();
				}
			}
		}
	}

	public void updateRobot(RobotState state) {
		short teamID = state.getTeamId();
		short robotID = state.getRobotId();
		int message = state.getMessage();
		byte team;

		logger.fine("received message from " + teamID + "/" + robotID + " : " + message);

		if (teamID == data.getTeamNumber(TEAM_1)) {
			team = TEAM_1;
		} else if (teamID == data.getTeamNumber(TEAM_2)) {
			team = TEAM_2;
		} else {
			System.out.println("received message from unkown team " + teamID + " (player " + robotID + ") : " + message);
			return;
		}

		switch (message) {
			case Constants.GAMECONTROLLER_RETURN_MSG_MAN_PENALISE: // robot has been manually penalised
				applyPenalty(team, robotID, Constants.PENALTY_MANUAL);
				break;
			case Constants.GAMECONTROLLER_RETURN_MSG_MAN_UNPENALISE: // robot has been manually unpenalised
				unpenalisePlayer(team, (byte) robotID);
				break;
			case Constants.GAMECONTROLLER_RETURN_MSG_ALIVE: // nothing to do, just a placeholder for alive message
				break;
            case Constants.GAMECONTROLLER_RETURN_MSG_REQUEST_FOR_SUBSTITUTION:	// robot is asking to be picked up
                requestForSubstitute(team, robotID);
                break;
			default:
				System.out.println("Unknown message, " + message + ", from player " + robotID + " on team " + teamID);
				break;
		}
		
		updateTimeLastSeen(team, (byte) robotID, System.currentTimeMillis());
	}
	
	// update the time when a robot send the last package
	public void updateTimeLastSeen(byte team, byte player, long time) {
		data.updateTimeLastSeen(team, player, time);
		cmdTeam[team][player].setPlayerSeen(time);
	}	

	private JCheckBox chkAutoPause;
	private JComboBox cmbHalf;
	private NamedComboBoxModel comboBoxModelHalf;

	protected JComboBox[] goalColourTeam;
	
	protected PlayerButton[][] cmdTeam;


	private JToggleButton cmdDropBall;

	private JButton[] cmdTeamDropIn;
	private JToggleButton[] cmdTeamKickOff;
	private JButton[] cmdTeamScoreDown;
	private JButton[] cmdTeamScoreUp;

	private JToggleButton cmdInitial;
	private JToggleButton cmdReady;
	private JToggleButton cmdSet;
	private JToggleButton cmdKickOff;
	private JToggleButton cmdFinish;

	private ButtonGroup penaltyButtons;
	private JToggleButton cmdInvisible;

	private JButton cmdSwitchTeams;

	private JButton cmdTimeReset;
	private JButton cmdTimeStart;
	private ButtonGroup gameButtons;
	private ButtonGroup kickOffButtons;

	private JLabel[] lblTeamScore;
	private JLabel[] lblTeam;
	private JLabel[] lblTeamLogo;
	private JLabel[] lblTeamPushCount;

	
	private TimeTextField lblTime;
	private TimeTextField lblSpecialEventTime;

	private JButton[] cmdTeamTimeOut;

	private JButton cmdTimeOutDone;

	private JPanel pnlSpecialEventTime;
	private JPanel[] pnlTeam;
	private JPanel pnlScore;
	private JPanel[] pnlTeamScore;
	private JPanel[] pnlTeamScoreUpDown;

	private ImageIcon[] teamLogo;

}
